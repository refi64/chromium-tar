// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_CHROMEOS_PLATFORM_KEYS_KEY_PERMISSIONS_KEY_PERMISSIONS_MANAGER_H_
#define CHROME_BROWSER_CHROMEOS_PLATFORM_KEYS_KEY_PERMISSIONS_KEY_PERMISSIONS_MANAGER_H_

#include <memory>
#include <string>
#include <vector>

#include "base/callback_forward.h"
#include "chrome/browser/chromeos/platform_keys/platform_keys.h"

namespace chromeos {
namespace platform_keys {

// This class manages permissions for extensions to use private keys through
// chrome.platformKeys or chrome.enterprise.platformKeys .
// The permission model depends on whether the user account is managed or not.
//
// ** If the user account is not managed **
// The user is under full control of the keys that are generated or imported
// while the device is not managed.  For that, a user can grant a specific
// extension the permission to sign arbitrary data with a specific key for an
// unlimited number of times.
//
// ** If the user account is managed **
// The administrator is in charge of granting access to keys that are meant for
// corporate usage.
//
// As not every key is meant for corporate usage but probably for the user's
// private usage, this class introduces the concept of tagging keys with the
// intended purpose of the key. Currently, the only usage that can be assigned
// to a key is "corporate".
//
// Every key that is generated by the chrome.enterprise.platformKeys API (which
// requires the user account to be managed), is marked for corporate usage.
// Any key that is generated or imported by other means is currently not marked
// for corporate usage.
//
// The KeyPermissions policy allows the administrator to list exactly the
// extensions that are allowed to use such corporate keys. Non-corporate keys
// are not affected. This policy is the only means to grant this permission.
//
// ** One-off Permission for the Certification Requests **
// Independent of the above, the extension that generates a key using the
// chrome.enterprise.platformKeys API is allowed to sign arbitrary data with the
// private key for a single time in order to create a certification request.
// The assumption is that certification requests usually require a signature of
// data including the public key. So the one-off permission implies that once a
// certificate authority creates the certificate of the generated key, the
// generating extension isn't able to use the key anymore except if explicitly
// permitted by the administrator.
//
// For retrieving a profile-specific KeyPermissionsManager, use
// KeyPermissionsManagerUserServiceFactory.
class KeyPermissionsManager {
 public:
  // Allows querying and modifying permissions and registering keys for a
  // specific extension.
  class PermissionsForExtension {
   public:
    PermissionsForExtension();
    virtual ~PermissionsForExtension();

    // Returns true if the private key matching |public_key_spki_der| can be
    // used for signing by the extension with id |extension_id_|.
    // |key_locations| must describe locations available to the user the private
    // key is stored on.
    virtual bool CanUseKeyForSigning(
        const std::string& public_key_spki_der,
        const std::vector<platform_keys::TokenId>& key_locations) = 0;

    // Registers the private key matching |public_key_spki_der| as being
    // generated by the extension with id |extension_id| and marks it for
    // corporate usage. |key_locations| must describe locations available to the
    // user the private key is stored on.
    virtual void RegisterKeyForCorporateUsage(
        const std::string& public_key_spki_der,
        const std::vector<platform_keys::TokenId>& key_locations) = 0;

    // Sets the user granted permission that the extension with id
    // |extension_id| can use the private key matching |public_key_spki_der| for
    // signing. |key_locations| must describe locations available to the user
    // the private key is stored on.
    virtual void SetUserGrantedPermission(
        const std::string& public_key_spki_der,
        const std::vector<platform_keys::TokenId>& key_locations) = 0;

    // Must be called when the extension with id |extension_id| used the private
    // key matching |public_key_spki_der| for signing. |key_locations| must
    // describe locations available to the user the private key is stored on.
    // Updates the permissions accordingly.  E.g. if this extension generated
    // the key and no other permission was granted then the permission to sign
    // with this key is removed.
    virtual void SetKeyUsedForSigning(
        const std::string& public_key_spki_der,
        const std::vector<platform_keys::TokenId>& key_locations) = 0;
  };

  KeyPermissionsManager();
  virtual ~KeyPermissionsManager();

  using PermissionsCallback =
      base::Callback<void(std::unique_ptr<PermissionsForExtension>)>;

  // Passes an object managing the key permissions of the extension with id
  // |extension_id| to |callback|. This can happen synchronously or
  // asynchronously.
  virtual void GetPermissionsForExtension(
      const std::string& extension_id,
      const PermissionsCallback& callback) = 0;

  // Returns true if the user can grant any permission for
  // |public_key_spki_derey_id| to extensions. |key_locations| must describe
  // locations available to the user the private key is stored on.
  virtual bool CanUserGrantPermissionFor(
      const std::string& public_key_spki_der,
      const std::vector<platform_keys::TokenId>& key_locations) const = 0;

  // Returns true if the key identified by |public_key_spki_der| that is
  // located on |key_locations| is marked for corporate usage.
  virtual bool IsCorporateKey(
      const std::string& public_key_spki_der,
      const std::vector<platform_keys::TokenId>& key_locations) const = 0;

  // Marks the key identified by |public_key_spki_der| as corporate usage.
  // Accepts a single key location because this is intended for usage after key
  // generation / import, when exactly one location is relevant.
  virtual void SetCorporateKey(const std::string& public_key_spki_der,
                               platform_keys::TokenId key_location) const = 0;
};

}  // namespace platform_keys
}  // namespace chromeos

#endif  // CHROME_BROWSER_CHROMEOS_PLATFORM_KEYS_KEY_PERMISSIONS_KEY_PERMISSIONS_MANAGER_H_
